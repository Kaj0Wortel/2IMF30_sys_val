%% Rail structure:
%%                   [/4-][-5|]
%% [|0-][-1-][-2-][-3+][-6-][-7|]
%%                   [\8-][-9|]
%% 
%% Repair bays (bay, rail)          : (0, 0), (1, 5), (2, 7), (3, 9)
%% Blast furnace (rail)             : (1)
%% Refinaries (refinery, rail)      : (0, 4), (1, 6), (2, 8)
%% Rail switch (rail)               : (3)
%% Init cart positions (cart, rail) : (0, 0), (1, 1), (2, 2), (3, 3)

sort Rail = struct rail(id: Nat);
sort Switch = struct switch(id: Nat);
sort Cart = struct cart(id: Nat, loc: Rail, next: Rail, broken: Bool, maintain: Bool, unload: Bool, empty: Bool);
sort Refinery = struct refinery(id: Nat);
sort State = struct state_cons(cart0: Cart, cart1: Cart, cart2: Cart, cart3: Cart, ref0: Refinery, ref1: Refinery, ref2: Refinery, switch: Switch);


% Initalize mappings.
map
	%% Carts
	get_id: Cart -> Nat;
	get_rail: Cart -> Rail;
	get_next: Cart -> Rail;
	set_rail: Rail # Cart -> Cart;
	set_next: Rail # Cart -> Cart;
	
    is_broken: Cart -> Bool;
    needs_main: Cart -> Bool;
	is_unloading: Cart -> Bool;
    is_empty: Cart -> Bool;
	
	init_cart: Nat # Nat -> Cart;
	forward: Cart # Switch -> Cart;
	backward: Cart -> Cart;
	move_to_target: Cart -> Cart;
	
	%% Switch
	init_switch: Switch;
	get_id: Switch -> Nat;
	
	%% Rails
	% Gets the ID of the rail.
	get_id: Rail -> Nat;
	% Whether moving the cart forward is allowed, ignoring other carts.
	allow_next: Rail # Switch -> Bool;
	% Set the target of the cart to the next rail segment.
	next: Rail # Switch -> Rail;
	% Whether moving the cart backward is allowed, ignoring other carts.
	allow_prev: Rail -> Bool;
	% Set the target of the cart to the previous rail segment.
	prev: Rail -> Rail;
	% Whether the next rail is free for the given cart
	%allow_rail: Rail # Cart -> Bool;
	
	%% Refineries
	get_id: Refinery -> Nat;
	
	%% State
	init_state: State;
	get_cart: Nat # State -> Cart;
	get_refinery: Nat # State -> Refinery;
	get_switch: State -> Switch;
	
	set_cart: Nat # Cart # State -> State;
	set_refinery: Nat # Refinery # State -> State;
	set_switch: Switch # State -> State;
	
	forward: Nat # State -> State;
	backward: Nat # State -> State;
	move_to_target: Nat # State -> State;
	

% Define refinery equations.
var n: Nat;
eqn
	get_id(refinery(n)) = n;


% Define rail equations.
var n, s: Nat;
	sw: Switch;
	c: Cart;
eqn
	get_id(rail(n)) = n;
	
	allow_next(rail(n), switch(s)) = ((n >= 0 && (n < 5 || n == 6 || n == 8))) && (s >= 0 && s <= 2);
	next(rail(3), switch(0)) = rail(4);
	next(rail(3), switch(1)) = rail(6);
	next(rail(3), switch(2)) = rail(8);
	allow_next(rail(n), sw) && n != 3 -> next(rail(n), sw) = rail(n + 1);

	allow_prev(rail(n)) = (n >= 1 && n <= 9);
	n == 8 || n == 6 || n == 4 -> prev(rail(n)) = rail(3);
	n != 8 && n != 6 && n != 4 && n != 0 -> prev(rail(n)) = rail(Int2Nat(n - 1));

%	allow_rail(rail(n), c) = true;


% Define cart equations.
var n, rn: Nat;
	r, nxt, rNew: Rail;
	br, main, unl, emp: Bool;
	sw: Switch;
eqn
	get_id(cart(n, r, nxt, br, main, unl, emp)) = n;
	get_rail(cart(n, r, nxt, br, main, unl, emp)) = r;
	get_next(cart(n, r, nxt, br, main, unl, emp)) = nxt;
	set_rail(rNew, cart(n, r, nxt, br, main, unl, emp)) = cart(n, rNew, nxt, br, main, unl, emp);
	set_next(rNew, cart(n, r, nxt, br, main, unl, emp)) = cart(n, r, rNew, br, main, unl, emp);
	is_broken(cart(n, r, nxt, br, main, unl, emp)) = br;
	needs_main(cart(n, r, nxt, br, main, unl, emp)) = main;
	is_unloading(cart(n, r, nxt, br, main, unl, emp)) = unl;
	is_empty(cart(n, r, nxt, br, main, unl, emp)) = emp;

	init_cart(n, rn) = cart(n, rail(rn), rail(rn), false, false, false, true);

	forward(cart(n, r, nxt, br, main, unl, emp), sw) = cart(n, r, next(nxt, sw), br, main, unl, emp);
	backward(cart(n, r, nxt, br, main, unl, emp)) = cart(n, r, prev(r), br, main, unl, emp);
	move_to_target(cart(n, r, nxt, br, main, unl, emp)) = cart(n, nxt, nxt, br, main, unl, emp);


% Define switch equations.
var n: Nat;
eqn
	init_switch = switch(0);
	get_id(switch(n)) = n;


% Define state equations.
var c, c0, c1, c2, c3: Cart;
	r, r0, r1, r2: Refinery;
	s, sw: Switch;
	n: Nat;
eqn
	init_state = state_cons(init_cart(0, 0), init_cart(1, 1), init_cart(2, 2), init_cart(3, 3), refinery(0), refinery(1), refinery(2), init_switch);

	(n == 0) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c0;
	(n == 1) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c1;
	(n == 2) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c2;
	(n == 3) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c3;
	(n == 0) -> get_refinery(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r0;
	(n == 1) -> get_refinery(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r1;
	(n == 2) -> get_refinery(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r2;
	get_switch(state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = sw;

	(n == 0) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c, c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c, c2, c3, r0, r1, r2, sw);
	(n == 2) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c, c3, r0, r1, r2, sw);
	(n == 3) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c, r0, r1, r2, sw);
	(n == 0) -> set_refinery(n, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r, r1, r2, sw);
	(n == 1) -> set_refinery(n, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r, r2, sw);
	(n == 2) -> set_refinery(n, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r1, r, sw);
	set_switch(s, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r1, r2, s);
	
	(n == 0) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(forward(c0, sw), c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, forward(c1, sw), c2, c3, r0, r1, r2, sw);
	(n == 2) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, forward(c2, sw), c3, r0, r1, r2, sw);
	(n == 3) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, forward(c3, sw), r0, r1, r2, sw);
	(n == 0) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(backward(c0), c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, backward(c1), c2, c3, r0, r1, r2, sw);
	(n == 2) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, backward(c2), c3, r0, r1, r2, sw);
	(n == 3) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, backward(c3), r0, r1, r2, sw);
	(n == 0) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(move_to_target(c0), c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, move_to_target(c1), c2, c3, r0, r1, r2, sw);
	(n == 2) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, move_to_target(c2), c3, r0, r1, r2, sw);
	(n == 3) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, move_to_target(c3), r0, r1, r2, sw);


act
	mSendCartForward, cSendCartForward, sendCartForward: Nat # Cart # Switch;
	mSendCartBackward, cSendCartBackward, sendCartBackward: Nat # Cart;
	mCartOnSegment, cCartOnSegment, cartOnSegment: Cart # Rail;
	switchRail: Switch;

glob state: State;
proc
	CartProc(num: Nat) =
			sum c: Cart . sum sw: Switch . cSendCartForward(num, c, sw) . CartMove(forward(c, sw)) +
			sum c: Cart . cSendCartBackward(num, c) . CartMove(backward(c));
	CartMove(c: Cart) = cCartOnSegment(c, get_next(c)) . CartProc(get_id(c));
	
	Main(s: State) =
			sum n: Nat . (n >= 0 && n < 4 && allow_next(get_rail(get_cart(n, s)), get_switch(s)))
				-> mSendCartForward(n, get_cart(n, s), get_switch(s)) . Main(forward(n, s)) + 
			sum n: Nat . (n >= 0 && n < 4 && allow_prev(get_rail(get_cart(n, s))))
				-> mSendCartBackward(n, get_cart(n, s)) . Main(backward(n, s)) + 
			sum n: Nat . sum r: Rail . (n >= 0 && n < 4)
				-> mCartOnSegment(get_cart(n, s), get_next(get_cart(n, s))) . Main(move_to_target(n, s)) + 
			sum n: Nat . (n >= 0 && n < 3 && n != get_id(get_switch(s)))
				-> (switchRail(switch(n)) . Main(set_switch(switch(n), s)));


init
	allow (
		{ sendCartForward, sendCartBackward, cartOnSegment, switchRail },
		comm ({
				mSendCartForward | cSendCartForward -> sendCartForward,
				mSendCartBackward | cSendCartBackward -> sendCartBackward,
				mCartOnSegment | cCartOnSegment -> cartOnSegment
			},
			Main(init_state) ||
				CartProc(0) ||
				CartProc(1) ||
				CartProc(2) ||
				CartProc(3)
		)
	);
	



