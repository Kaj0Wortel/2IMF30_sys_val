%% Rail structure:
%%                   [/4-][-5|]
%% [|0-][-1-][-2-][-3+][-6-][-7|]
%%                   [\8-][-9|]
%% 
%% Repair bays (bay, rail)          : (0, 0), (1, 5), (2, 7), (3, 9)
%% Blast furnace (rail)             : (1)
%% Refinaries (refinery, rail)      : (0, 4), (1, 6), (2, 8)
%% Rail switch (rail)               : (3)
%% Init cart positions (cart, rail) : (0, 0), (1, 1), (2, 2), (3, 3)

sort Rail = struct rail(id: Nat);
sort Switch = struct switch(id: Nat);
sort Cart = struct cart(id: Nat, loc: Rail, target: Rail, broken: Bool, maintain: Bool, unload: Bool, empty: Bool);
sort Refinery = struct refinery(id: Nat);
sort State = struct state_cons(cart0: Cart, cart1: Cart, cart2: Cart, cart3: Cart, ref0: Refinery, ref1: Refinery, ref2: Refinery, switch: Switch);


% Initalize mappings.
map
	%% Carts
	% Gets the ID of the cart.
	get_id: Cart -> Nat;
	% Gets the current position of the cart.
	get_rail: Cart -> Rail;
	% Gets the target of the cart.
	get_target: Cart -> Rail;
	% Sets the curent position of the cart.
	set_rail: Rail # Cart -> Cart;
	% Sets the target of the cart.
	set_target: Rail # Cart -> Cart;
	
	% Returns true if the cart is broken. False otherwise.
    is_broken: Cart -> Bool;
	% Returns true if the cart needs maintenance. False otherwise.
    needs_main: Cart -> Bool;
	% Returns true if the cart is unloading. False otherwise.
	is_unloading: Cart -> Bool;
	% Returns true if the cart is empty. False otherwise.
    is_empty: Cart -> Bool;
	
	init_cart: Nat # Nat -> Cart;
	% Sets the target of the cart one position forward relative to the current position.
	forward: Cart # Switch -> Cart;
	% Sets the target of the cart one position backward relative to the current position.
	backward: Cart -> Cart;
	% Sets the current location of the cart to the value of the target of the cart.
	move_to_target: Cart -> Cart;
	
	%% Switch
	% Initializes the switch.
	init_switch: Switch;
	% Gets the ID of the switch.
	get_id: Switch -> Nat;
	
	%% Rails
	% Gets the ID of the rail.
	get_id: Rail -> Nat;
	% Whether the next rail segment exists.
	allow_next: Rail # Switch -> Bool;
	% Returns the next rail segment of the given rail segment.
	next: Rail # Switch -> Rail;
	% Whether the previous rail segment exists.
	allow_prev: Rail -> Bool;
	% Returns the previous rail segment of the given rail segment.
	prev: Rail -> Rail;
	
	%% Refineries
	% Gets the ID of the refinery.
	get_id: Refinery -> Nat;
	
	%% State
	% Initializes the state.
	init_state: State;
	% Gets the cart at the given position.
	get_cart: Nat # State -> Cart;
	% Gets the refinery at the given position.
	get_refinery: Nat # State -> Refinery;
	% Gets the switch.
	get_switch: State -> Switch;
	
	% Sets the cart at the position with the given ID.
	set_cart: Nat # Cart # State -> State;
	% Set the refinery at the position with the given ID.
	set_refinery: Nat # Refinery # State -> State;
	% Sets the switch.
	set_switch: Switch # State -> State;
	
	% Sets the target of the cart with the given ID one position forward relative to the current position.
	forward: Nat # State -> State;
	% Sets the target of the cart with the given ID one position backward relative to the current position.
	backward: Nat # State -> State;
	% Sets the current location of the cart with the given ID to the value of the target of the cart.
	move_to_target: Nat # State -> State;
	% Whether the next rail is free for the given cart
	allow_movement: Nat # Rail # State -> Bool;
	

% Define refinery equations.
var n: Nat;
eqn
	get_id(refinery(n)) = n;


% Define rail equations.
var n, s: Nat;
	sw: Switch;
	c: Cart;
eqn
	get_id(rail(n)) = n;
	
	allow_next(rail(n), switch(s)) = ((n >= 0 && (n < 5 || n == 6 || n == 8))) && (s >= 0 && s <= 2);
	next(rail(3), switch(0)) = rail(4);
	next(rail(3), switch(1)) = rail(6);
	next(rail(3), switch(2)) = rail(8);
	allow_next(rail(n), sw) && n != 3 -> next(rail(n), sw) = rail(n + 1);

	allow_prev(rail(n)) = (n >= 1 && n <= 9);
	n == 8 || n == 6 || n == 4 -> prev(rail(n)) = rail(3);
	n != 8 && n != 6 && n != 4 && n != 0 -> prev(rail(n)) = rail(Int2Nat(n - 1));

%	allow_rail(rail(n), c) = true;


% Define cart equations.
var n, rn: Nat;
	r, trgt, rNew: Rail;
	br, main, unl, emp: Bool;
	sw: Switch;
eqn
	get_id(cart(n, r, trgt, br, main, unl, emp)) = n;
	get_rail(cart(n, r, trgt, br, main, unl, emp)) = r;
	get_target(cart(n, r, trgt, br, main, unl, emp)) = trgt;
	set_rail(rNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, rNew, trgt, br, main, unl, emp);
	set_target(rNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, rNew, br, main, unl, emp);
	is_broken(cart(n, r, trgt, br, main, unl, emp)) = br;
	needs_main(cart(n, r, trgt, br, main, unl, emp)) = main;
	is_unloading(cart(n, r, trgt, br, main, unl, emp)) = unl;
	is_empty(cart(n, r, trgt, br, main, unl, emp)) = emp;

	init_cart(n, rn) = cart(n, rail(rn), rail(rn), false, false, false, true);

	forward(cart(n, r, trgt, br, main, unl, emp), sw) = cart(n, r, next(r, sw), br, main, unl, emp);
	backward(cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, prev(r), br, main, unl, emp);
	move_to_target(cart(n, r, trgt, br, main, unl, emp)) = cart(n, trgt, trgt, br, main, unl, emp);


% Define switch equations.
var n: Nat;
eqn
	init_switch = switch(0);
	get_id(switch(n)) = n;


% Define state equations.
var c, c0, c1, c2, c3: Cart;
	r, r0, r1, r2: Refinery;
	s, sw: Switch;
	n: Nat;
	rl: Rail;
	st: State;
eqn
	init_state = state_cons(init_cart(0, 0), init_cart(1, 1), init_cart(2, 2), init_cart(3, 3), refinery(0), refinery(1), refinery(2), init_switch);
	
	(n == 0) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c0;
	(n == 1) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c1;
	(n == 2) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c2;
	(n == 3) -> get_cart(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c3;
	(n == 0) -> get_refinery(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r0;
	(n == 1) -> get_refinery(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r1;
	(n == 2) -> get_refinery(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r2;
	get_switch(state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = sw;
	
	(n == 0) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c, c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c, c2, c3, r0, r1, r2, sw);
	(n == 2) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c, c3, r0, r1, r2, sw);
	(n == 3) -> set_cart(n, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c, r0, r1, r2, sw);
	(n == 0) -> set_refinery(n, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r, r1, r2, sw);
	(n == 1) -> set_refinery(n, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r, r2, sw);
	(n == 2) -> set_refinery(n, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r1, r, sw);
	set_switch(s, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r1, r2, s);
	
	(n == 0) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(forward(c0, sw), c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, forward(c1, sw), c2, c3, r0, r1, r2, sw);
	(n == 2) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, forward(c2, sw), c3, r0, r1, r2, sw);
	(n == 3) -> forward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, forward(c3, sw), r0, r1, r2, sw);
	(n == 0) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(backward(c0), c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, backward(c1), c2, c3, r0, r1, r2, sw);
	(n == 2) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, backward(c2), c3, r0, r1, r2, sw);
	(n == 3) -> backward(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, backward(c3), r0, r1, r2, sw);
	(n == 0) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(move_to_target(c0), c1, c2, c3, r0, r1, r2, sw);
	(n == 1) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, move_to_target(c1), c2, c3, r0, r1, r2, sw);
	(n == 2) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, move_to_target(c2), c3, r0, r1, r2, sw);
	(n == 3) -> move_to_target(n, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, move_to_target(c3), r0, r1, r2, sw);
	
	allow_movement(n, rl, st) = forall num: Nat . (num >= 0 && num < 4) => (
            num == n || (get_rail(get_cart(num, st)) != rl && get_target(get_cart(num, st)) != rl)
    );


act
	mSendCartForward, cSendCartForward, sendCartForward: Nat # Cart # Switch;
	mSendCartBackward, cSendCartBackward, sendCartBackward: Nat # Cart;
	mCartOnSegment, cCartOnSegment, cartOnSegment: Cart # Rail;
	switchRail: Switch;
	test, skip, cont;


glob state: State;
proc
	%%%%%%%%%%%%%%%%%%%%%
	%% Cart procedures %%
	%%%%%%%%%%%%%%%%%%%%%
	% Main procedure of a cart.
	CartProc(num: Nat) =
			sum c: Cart . sum sw: Switch . cSendCartForward(num, c, sw) . SignalCartMoved(forward(c, sw)) +
			sum c: Cart . cSendCartBackward(num, c) . SignalCartMoved(backward(c));
	
	% Procedure to notify the main system that a cart has moved.
	SignalCartMoved(c: Cart) = cCartOnSegment(c, get_target(c)) . CartProc(get_id(c));
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Main system procedures %%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Main procedure of the system.
	MainProc(s: State) = Test(s) + 
			sum cID: Nat . (cID >= 0 && cID < 4) -> (MoveCartForward(s, cID) + MoveCartBackward(s, cID) + DetectCartMoved(s, cID)) +
			sum n: Nat . (n >= 0 && n < 3) -> MoveSwitch(s, n);
	
	% Procedure to move the cart with the given ID one step forward.
	MoveCartForward(s: State, cID: Nat) = (allow_next(get_rail(get_cart(cID, s)), get_switch(s)) &&
				allow_movement(cID, next(get_rail(get_cart(cID, s)), get_switch(s)), s))
			-> mSendCartForward(cID, get_cart(cID, s), get_switch(s)) . MainProc(forward(cID, s));
	
	% Procedure to move the cart with the given ID one step backward.
	MoveCartBackward(s: State, cID: Nat) = (allow_prev(get_rail(get_cart(cID, s))) &&
					allow_movement(cID, prev(get_rail(get_cart(cID, s))), s))
				-> mSendCartBackward(cID, get_cart(cID, s)) . MainProc(backward(cID, s));
	
	% Procedure to detect movement from a cart.
	DetectCartMoved(s: State, cID: Nat) = mCartOnSegment(get_cart(cID, s), get_target(get_cart(cID, s))) . MainProc(move_to_target(cID, s));
	
	% Procedure to move the rail switch.
	MoveSwitch(s: State, n: Nat) = (n != get_id(get_switch(s)))
				-> (switchRail(switch(n)) . MainProc(set_switch(switch(n), s)));
	
	Test(s: State) = test . (skip + (allow_movement(3, rail(4), s)) -> cont) . MainProc(s);

init
	allow (
		{ sendCartForward, sendCartBackward, cartOnSegment, switchRail, test, skip, cont },
		comm ({
				mSendCartForward | cSendCartForward -> sendCartForward,
				mSendCartBackward | cSendCartBackward -> sendCartBackward,
				mCartOnSegment | cCartOnSegment -> cartOnSegment
			},
			MainProc(init_state) ||
				CartProc(0) ||
				CartProc(1) ||
				CartProc(2) ||
				CartProc(3)
		)
	);
	



