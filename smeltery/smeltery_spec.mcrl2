%% Rail structure:
%%                   [/4-][-5|]
%% [|0-][-1-][-2-][-3+][-6-][-7|]
%%                   [\8-][-9|]
%% 
%% Repair bays (bay, rail)          : (0, 0), (1, 5), (2, 7), (3, 9)
%% Blast furnace (rail)             : (1)
%% Refinaries (refinery, rail)      : (0, 4), (1, 6), (2, 8)
%% Rail switch (rail)               : (3)
%% Init cart positions (cart, rail) : (0, 0), (1, 1), (2, 2), (3, 3)

sort Rail = struct rail(id: Nat);
sort Switch = struct switch(id: Nat);
sort Cart = struct cart(id: Nat, loc: Rail, target: Rail, broken: Bool, maintain: Bool, unload: Bool, empty: Bool);
sort Refinery = struct refinery(id: Nat, req: Bool, broken: Bool);
sort State = struct state_cons(cart0: Cart, cart1: Cart, cart2: Cart, cart3: Cart, ref0: Refinery, ref1: Refinery, ref2: Refinery, switch: Switch);


% Initalize mappings.
map
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Carts
	% Gets the ID of the cart.
	get_id: Cart -> Nat;
	% Gets the current position of the cart.
	get_rail: Cart -> Rail;
	% Gets the target of the cart.
	get_target: Cart -> Rail;
	% Returns true if the cart is broken. False otherwise.
    is_broken: Cart -> Bool;
	% Returns true if the cart needs maintenance. False otherwise.
    needs_main: Cart -> Bool;
	% Returns true if the cart is unloading. False otherwise.
	is_unloading: Cart -> Bool;
	% Returns true if the cart is empty. False otherwise.
    is_empty: Cart -> Bool;
	
	% Sets the curent position of the cart.
	set_rail: Rail # Cart -> Cart;
	% Sets the target of the cart.
	set_target: Rail # Cart -> Cart;
	% Sets whether the cart is broken.
	set_broken: Bool # Cart -> Cart;
	% Sets whether the cart requests maintenance.
	set_maintain: Bool # Cart -> Cart;
	% Sets whether the cart is unloading.
	set_unloading: Bool # Cart -> Cart;
	% Sets whether the cart is empty.
	set_empty: Bool # Cart -> Cart;
	
	% Lazy initializer for a cart.
	init_cart: Nat # Nat -> Cart;
	% Sets the target of the cart one position forward relative to the current position.
	forward: Cart # Switch -> Cart;
	% Sets the target of the cart one position backward relative to the current position.
	backward: Cart -> Cart;
	% Sets the current location of the cart to the value of the target of the cart.
	move_to_target: Cart -> Cart;
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Switch
	% Lazy initializer for a switch.
	init_switch: Switch;
	% Gets the ID of the switch.
	get_id: Switch -> Nat;
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Rails
	% Gets the ID of the rail.
	get_id: Rail -> Nat;
	% Whether the next rail segment exists.
	allow_next: Rail # Switch -> Bool;
	% Returns the next rail segment of the given rail segment.
	next: Rail # Switch -> Rail;
	% Whether the previous rail segment exists.
	allow_prev: Rail -> Bool;
	% Returns the previous rail segment of the given rail segment.
	prev: Rail -> Rail;
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Refineries
	% Lazy initializer for a refinery.
	init_refinery: Nat -> Refinery;
	% Gets the ID of the refinery.
	get_id: Refinery -> Nat;
	% Whether the refinery requests iron.
	has_request: Refinery -> Bool;
	% Whether the refinery is broken.
	is_broken: Refinery -> Bool;
	
	% Sets whether the refinery has a request.
	set_request: Bool # Refinery -> Refinery;
	% Sets whether the refinery is broken.
	set_broken: Bool # Refinery -> Refinery;
	
	% Returns the rail segment the refinery is located at.
	get_rail: Refinery -> Rail;
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% State
	% Lazy initializer for a state.
	init_state: State;
	% Gets the cart at the given position.
	get_cart: Nat # State -> Cart;
	% Gets the refinery at the given position.
	get_refinery: Nat # State -> Refinery;
	% Gets the switch.
	get_switch: State -> Switch;
	
	% Sets the cart at the position with the given ID.
	set_cart: Nat # Cart # State -> State;
	% Set the refinery at the position with the given ID.
	set_refinery: Nat # Refinery # State -> State;
	% Sets the switch.
	set_switch: Switch # State -> State;
	
	% Sets the target of the cart with the given ID one position forward relative to the current position.
	forward: Nat # State -> State;
	% Sets the target of the cart with the given ID one position backward relative to the current position.
	backward: Nat # State -> State;
	% Sets the current location of the cart with the given ID to the value of the target of the cart.
	move_to_target: Nat # State -> State;
	% Whether the next rail is free for the given cart
	allow_movement: Nat # Rail # State -> Bool;
	% Whether the rail switch is allowed to be used.
	allow_switch: State -> Bool;
	

% Define refinery equations.
var n: Nat;
	r, b, new: Bool;
eqn
	get_id(refinery(n, r, b)) = n;
	has_request(refinery(n, r, b)) = r;
	is_broken(refinery(n, r, b)) = b;
	init_refinery(n) = refinery(n, false, false);
	
	set_request(new, refinery(n, r, b)) = refinery(n, new, b);
	set_broken(new, refinery(n, r, b)) = refinery(n, r, new);
	
	get_rail(refinery(0, r, b)) = rail(4);
	get_rail(refinery(1, r, b)) = rail(6);
	get_rail(refinery(2, r, b)) = rail(8);


% Define rail equations.
var n, s: Nat;
	sw: Switch;
	c: Cart;
eqn
	get_id(rail(n)) = n;
	
	allow_next(rail(n), switch(s)) = ((n >= 0 && (n < 5 || n == 6 || n == 8))) && (s >= 0 && s <= 2);
	next(rail(3), switch(0)) = rail(4);
	next(rail(3), switch(1)) = rail(6);
	next(rail(3), switch(2)) = rail(8);
	allow_next(rail(n), sw) && n != 3 -> next(rail(n), sw) = rail(n + 1);

	allow_prev(rail(n)) = (n >= 1 && n <= 9);
	n == 8 || n == 6 || n == 4 -> prev(rail(n)) = rail(3);
	n != 8 && n != 6 && n != 4 && n != 0 -> prev(rail(n)) = rail(Int2Nat(n - 1));


% Define cart equations.
var n, rn: Nat;
	r, trgt, rNew: Rail;
	br, main, unl, emp, bNew: Bool;
	sw: Switch;
eqn
	get_id(cart(n, r, trgt, br, main, unl, emp)) = n;
	get_rail(cart(n, r, trgt, br, main, unl, emp)) = r;
	get_target(cart(n, r, trgt, br, main, unl, emp)) = trgt;
	is_broken(cart(n, r, trgt, br, main, unl, emp)) = br;
	needs_main(cart(n, r, trgt, br, main, unl, emp)) = main;
	is_unloading(cart(n, r, trgt, br, main, unl, emp)) = unl;
	is_empty(cart(n, r, trgt, br, main, unl, emp)) = emp;
	
	init_cart(n, rn) = cart(n, rail(rn), rail(rn), false, false, false, true);
	
	forward(cart(n, r, trgt, br, main, unl, emp), sw) = cart(n, r, next(r, sw), br, main, unl, emp);
	backward(cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, prev(r), br, main, unl, emp);
	move_to_target(cart(n, r, trgt, br, main, unl, emp)) = cart(n, trgt, trgt, br, main, unl, emp);
	
	set_rail(rNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, rNew, trgt, br, main, unl, emp);
	set_target(rNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, rNew, br, main, unl, emp);
	set_broken(bNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, trgt, bNew, main, unl, emp);
	set_maintain(bNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, trgt, br, bNew, unl, emp);
	set_unloading(bNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, trgt, br, main, bNew, emp);
	set_empty(bNew, cart(n, r, trgt, br, main, unl, emp)) = cart(n, r, trgt, br, main, unl, bNew);


% Define switch equations.
var n: Nat;
eqn
	init_switch = switch(0);
	get_id(switch(n)) = n;


% Define state equations.
var c, c0, c1, c2, c3: Cart;
	r, r0, r1, r2: Refinery;
	s, sw: Switch;
	n: Nat;
	rl: Rail;
	st: State;
eqn
	init_state = state_cons(init_cart(0, 0), init_cart(1, 1), init_cart(2, 2), init_cart(3, 3), init_refinery(0), init_refinery(1), init_refinery(2), init_switch);
	
	get_cart(0, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c0;
	get_cart(1, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c1;
	get_cart(2, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c2;
	get_cart(3, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = c3;
	get_refinery(0, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r0;
	get_refinery(1, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r1;
	get_refinery(2, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = r2;
	get_switch(state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = sw;
	
	set_cart(0, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c, c1, c2, c3, r0, r1, r2, sw);
	set_cart(1, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c, c2, c3, r0, r1, r2, sw);
	set_cart(2, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c, c3, r0, r1, r2, sw);
	set_cart(3, c, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c, r0, r1, r2, sw);
	set_refinery(0, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r, r1, r2, sw);
	set_refinery(1, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r, r2, sw);
	set_refinery(2, r, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r1, r, sw);
	set_switch(s, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, c3, r0, r1, r2, s);
	
	forward(0, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(forward(c0, sw), c1, c2, c3, r0, r1, r2, sw);
	forward(1, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, forward(c1, sw), c2, c3, r0, r1, r2, sw);
	forward(2, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, forward(c2, sw), c3, r0, r1, r2, sw);
	forward(3, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, forward(c3, sw), r0, r1, r2, sw);
	backward(0, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(backward(c0), c1, c2, c3, r0, r1, r2, sw);
	backward(1, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, backward(c1), c2, c3, r0, r1, r2, sw);
	backward(2, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, backward(c2), c3, r0, r1, r2, sw);
	backward(3, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, backward(c3), r0, r1, r2, sw);
	move_to_target(0, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(move_to_target(c0), c1, c2, c3, r0, r1, r2, sw);
	move_to_target(1, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, move_to_target(c1), c2, c3, r0, r1, r2, sw);
	move_to_target(2, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, move_to_target(c2), c3, r0, r1, r2, sw);
	move_to_target(3, state_cons(c0, c1, c2, c3, r0, r1, r2, sw)) = state_cons(c0, c1, c2, move_to_target(c3), r0, r1, r2, sw);
	
	allow_movement(n, rl, st) = forall num: Nat . (num >= 0 && num < 4) => (
            num == n || (get_rail(get_cart(num, st)) != rl && get_target(get_cart(num, st)) != rl)
    );
	
	allow_switch(st) = forall crt: Nat . (crt >= 0 && crt < 4) => (
			get_rail(get_cart(crt, st)) != rail(3) && get_target(get_cart(crt, st)) != rail(3)
	);


act
	% Cart
	mSendCartForward, cSendCartForward, sendCartForward: Nat # Cart # Switch;
	mSendCartBackward, cSendCartBackward, sendCartBackward: Nat # Cart;
	mCartOnSegment, cCartOnSegment, cartOnSegment: Cart # Rail;
	% Refinery
	mRequestIron, rRequestIron, requestIron: Nat # Refinery;
	% Switch
	switchRail: Switch;


proc
	%%%%%%%%%%%%%%%%%%%%%
	%% Cart procedures %%
	%%%%%%%%%%%%%%%%%%%%%
	% Main procedure of a cart.
	CartProc(num: Nat) =
			sum c: Cart . (get_id(c) == num) -> (
				sum sw: Switch . cSendCartForward(num, c, sw) . SignalCartMoved(forward(c, sw)) +
				cSendCartBackward(num, c) . SignalCartMoved(backward(c))
			);
	
	% Procedure to signal the main system that a cart has moved.
	SignalCartMoved(c: Cart) = cCartOnSegment(c, get_target(c)) . CartProc(get_id(c));
	
	
	%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Refinery procedures %%
	%%%%%%%%%%%%%%%%%%%%%%%%%
	% Main procedure of the refineries.
	RefProc(num: Nat) = sum r: Refinery . (get_id(r) == num) -> SignalRequest(r);
	
	% Procedure to signal the main system that a refinery requests iron.
	SignalRequest(r: Refinery) = (!is_broken(r) && !has_request(r)) -> (rRequestIron(get_id(r), r) . RefProc(get_id(r)));
	
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Main system procedures %%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Main procedure of the system.
	MainProc(s: State) =
			sum cID: Nat . (cID < 4) -> (MoveCartForward(s, cID) + MoveCartBackward(s, cID) + DetectCartMoved(s, cID)) +
			sum sID: Nat . (sID < 3) -> MoveSwitch(s, sID) +
			sum rID: Nat . (rID < 3) -> DetectRequest(s, get_refinery(rID, s));
	
	% Procedure to move the cart with the given ID one step forward.
	MoveCartForward(s: State, cID: Nat) = (allow_next(get_rail(get_cart(cID, s)), get_switch(s)) &&
				allow_movement(cID, next(get_rail(get_cart(cID, s)), get_switch(s)), s))
			-> mSendCartForward(cID, get_cart(cID, s), get_switch(s)) . MainProc(forward(cID, s));
	
	% Procedure to move the cart with the given ID one step backward.
	MoveCartBackward(s: State, cID: Nat) = (allow_prev(get_rail(get_cart(cID, s))) &&
					allow_movement(cID, prev(get_rail(get_cart(cID, s))), s))
				-> mSendCartBackward(cID, get_cart(cID, s)) . MainProc(backward(cID, s));
	
	% Procedure to detect movement from a cart.
	DetectCartMoved(s: State, cID: Nat) = mCartOnSegment(get_cart(cID, s), get_target(get_cart(cID, s))) . MainProc(move_to_target(cID, s));
	
	% Procedure to detect a request of a refinery.
	DetectRequest(s: State, ref: Refinery) = mRequestIron(get_id(ref), ref) . MainProc(set_refinery(get_id(ref), set_request(true, ref), s));
	
	% Procedure to move the rail switch.
	MoveSwitch(s: State, sID: Nat) = (allow_switch(s) && sID != get_id(get_switch(s)))
				-> (switchRail(switch(sID)) . MainProc(set_switch(switch(sID), s)));


init
	allow (
		{ sendCartForward, sendCartBackward, cartOnSegment, switchRail, requestIron },
		comm ({
				mSendCartForward | cSendCartForward -> sendCartForward,
				mSendCartBackward | cSendCartBackward -> sendCartBackward,
				mCartOnSegment | cCartOnSegment -> cartOnSegment,
				mRequestIron | rRequestIron -> requestIron
			},
			MainProc(init_state) ||
				CartProc(0) ||
				CartProc(1) ||
				CartProc(2) ||
				CartProc(3) ||
				RefProc(0) ||
				RefProc(1) ||
				RefProc(2)
		)
	);


